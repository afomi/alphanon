<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Sine Wave Expansion</title>
  <link
    rel="stylesheet"
    href="./assets/css/nav.css">
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script type="module">
    import { injectNav } from './assets/js/nav.js';
    injectNav();
  </script>
  <script type="module">
    import * as THREE from './assets/js/three.js';
    import { OrbitControls } from './assets/js/orbitcontrols.js';

    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);




    // App setup
    const lineCount = 10;
    const pointsPerLine = 200;
    const baseAmplitude = 2;
    const baseFrequency = 0.2;

    const lines = [];

    for (let i = 0; i < lineCount; i++) {
      const scale = 1 + 0.1 * i;
      const geometry = new THREE.BufferGeometry();
      const positions = [];

      for (let j = 0; j < pointsPerLine; j++) {
        const x = j - pointsPerLine / 2;
        const y = Math.sin(x * baseFrequency) * baseAmplitude * scale;
        const z = i * 2; // offset in Z to show multiple lines
        positions.push(x, y, z);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

      const material = new THREE.LineBasicMaterial({ color: new THREE.Color(`hsl(${i * 36}, 100%, 50%)`) });
      const line = new THREE.Line(geometry, material);
      lines.push({ line, scale });
      scene.add(line);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Animate wave motion
      const time = performance.now() * 0.001;
      lines.forEach(({ line, scale }, i) => {
        const positions = line.geometry.attributes.position.array;
        for (let j = 0; j < pointsPerLine; j++) {
          const x = j - pointsPerLine / 2;
          const y = Math.sin(x * baseFrequency + time) * baseAmplitude * scale;
          // positions[j * 3 + 0] = y; // update x only
          // positions[j * 3 + 1] = y; // update y only
          // positions[j * 3 + 2] = y; // update z only
          // positions[j * 3 + 4] = y; // update z only
          // positions[j * 3 + 5] = y; // update z only
          positions[j * 3 + 6] = y; // update z only
        }
        line.geometry.attributes.position.needsUpdate = true;
      });

      renderer.render(scene, camera);
    }

    animate();
  </script>
  <script>
    // const scene = new THREE.Scene();
    // const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    // camera.position.z = 50;

    // const renderer = new THREE.WebGLRenderer({ antialias: true });
    // renderer.setSize(window.innerWidth, window.innerHeight);
    // document.body.appendChild(renderer.domElement);



  </script>
</body>

</html>